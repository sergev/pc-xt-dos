(* !LIBRARY! *) DEFINITION MODULE RealStr;

(* Proposed BSI/ISO Standard Modula-2 I/O Library
 * Copyright Roger Henry, University of Nottingham
 * Version WG/4.01, February 1989
 * Permission is given to copy this Definition Module, with the
 * copyright notice intact, for the purposes of evaluation and test.
 * At the stage of a formal draft standard, Copyright will be transferred
 * to BSI (and through BSI to other recognised standards bodies).
 * Status: for review by BSI/IST/5/13;
           for review by ISO/IEC JTC1/SC22/WG13
 --* this version editted to comform to D105 kjg September 1989 *--
*)

IMPORT ConvTypes;
FROM   ConvTypes IMPORT ScanProgress, ScanProc;

(* the text form of an real number is		                 *)
(* where w ~ whitespace, and d ~ decimal digit			 *)
(*      [w] ["+"|"-"] d{d} ["." {d}] ["E" ["+"|"-"] d{d}]        *)

PROCEDURE Scan(
      this: CHAR; VAR progress: ScanProgress; VAR nextScanner: ScanProc
);

TYPE
  ConvResults = ConvTypes.ConvResults;

PROCEDURE Format(str: ARRAY OF CHAR): ConvResults;
  (* pre:  "str" has a string value                              *)
  (* post: returned value corresponds to format of string        *)
  (*       value with respect to the type CARDINAL               *)

PROCEDURE Value(str: ARRAY OF CHAR): REAL;
  (* pre:  "str" has a string value                              *)
  (*       and format is "allRight" with respect to CARDINAL     *)
  (* post: returned value is the corresponding CARDINAL          *)

PROCEDURE Take(
  str: ARRAY OF CHAR; VAR real: REAL; VAR format: ConvResults
);
  (* pre:  "str" has a string value                              *)
  (* post: either value of "format" is "allRight",               *)
  (*         value of "real" is the corresponding REAL           *)
  (*       or value of "format" is "outOfRange",                 *)
  (*         value of "real" is the NaNS "HUGE"                  *)
  (*       or value of "format" is "wrongFormat"                 *)
  (*         value of "real" is undefined                        *)
  (*       or value of format is "noData"                        *)
  (*         value of "real" is unchanged                        *)

TYPE
  Alignment = ConvTypes.Alignment;

PROCEDURE LengthFloat(real: REAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the floating point      *)
  (* string of real using the given number of significant places *)

PROCEDURE GiveFloat(
	VAR str    : ARRAY OF CHAR;
	    real   : REAL;
	    sigFigs: CARDINAL;
	    width  : CARDINAL;
	    where  : Alignment
);
  (* post: as far as capacity of "str" allows,                             *)
  (*       the character representation of "real" is contained in "str"    *)
  (*       in a field of at least "width" characters                       *)
  (*	   using sigFigs significant places				   *)

PROCEDURE LengthEng(real: REAL; sigFigs: CARDINAL): CARDINAL;
  (* Returns the number of characters in the engineering format  *)
  (* string of real using the given number of significant places *)

PROCEDURE GiveEng(
	VAR str    : ARRAY OF CHAR;
	    real   : REAL;
	    sigFigs: CARDINAL;
	    width  : CARDINAL;
	    where  : Alignment
);
  (* post: as far as capacity of "str" allows,                             *)
  (*       the engineering representation of "real" is contained in "str"  *)
  (*       in a field of at least "width" characters                       *)
  (*	   using sigFigs significant places				   *)

PROCEDURE LengthFixed(real: REAL; place: INTEGER): CARDINAL;
  (* Returns the number of characters in the fixed point         *)
  (* string of real rounded at position "place". Positive values *)
  (* of "place" correspond to positions in the fraction part.    *)

PROCEDURE GiveFixed(
	VAR str    : ARRAY OF CHAR;
	    real   : REAL;
	    place  : INTEGER;
	    width  : CARDINAL;
	    where  : Alignment
);
  (* post: as far as capacity of "str" allows,                   *)
  (*       the fixed point representation of "real" is contained *)
  (*       in "str", rounded at position place. Positive values  *)
  (*       of "place" correspond to the fraction part.           *)

END RealStr.
